"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iron-session";
exports.ids = ["vendor-chunks/iron-session"];
exports.modules = {

/***/ "(rsc)/../../../node_modules/iron-session/dist/index.js":
/*!********************************************************!*\
  !*** ../../../node_modules/iron-session/dist/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  createGetIronSession: () => createGetIronSession,\n  createSealData: () => createSealData,\n  createUnsealData: () => createUnsealData,\n  getIronSession: () => getIronSession,\n  sealData: () => sealData,\n  unsealData: () => unsealData\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/core.ts\nvar Iron = __toESM(__webpack_require__(/*! iron-webcrypto */ \"(rsc)/../../../node_modules/iron-webcrypto/dist/index.js\"));\nvar import_cookie = __toESM(__webpack_require__(/*! cookie */ \"(rsc)/../../../node_modules/iron-session/node_modules/cookie/index.js\"));\nvar timestampSkewSec = 60;\nvar fourteenDaysInSeconds = 15 * 24 * 3600;\nvar currentMajorVersion = 2;\nvar versionDelimiter = \"~\";\nvar defaultOptions = {\n  ttl: fourteenDaysInSeconds,\n  cookieOptions: {\n    httpOnly: true,\n    secure: true,\n    sameSite: \"lax\",\n    path: \"/\"\n  }\n};\nfunction createGetIronSession(_crypto2, unsealData2, sealData2) {\n  return async (req, res, userSessionOptions) => {\n    if (!req || !res || !userSessionOptions || !userSessionOptions.cookieName || !userSessionOptions.password) {\n      throw new Error(\n        `iron-session: Bad usage. Minimum usage is const session = await getIronSession(req, res, { cookieName: \"...\", password: \"...\". Check the usage here: https://github.com/vvo/iron-session`\n      );\n    }\n    const passwordsAsMap = normalizeStringPasswordToMap(\n      userSessionOptions.password\n    );\n    Object.values(\n      normalizeStringPasswordToMap(userSessionOptions.password)\n    ).forEach((password) => {\n      if (password.length < 32) {\n        throw new Error(\n          `iron-session: Bad usage. Password must be at least 32 characters long.`\n        );\n      }\n    });\n    const options = {\n      ...defaultOptions,\n      ...userSessionOptions,\n      cookieOptions: {\n        ...defaultOptions.cookieOptions,\n        ...userSessionOptions.cookieOptions || {}\n      }\n    };\n    if (options.ttl === 0) {\n      options.ttl = 2147483647;\n    }\n    if (userSessionOptions.cookieOptions && \"maxAge\" in userSessionOptions.cookieOptions) {\n      if (userSessionOptions.cookieOptions.maxAge === void 0) {\n        options.ttl = 0;\n      } else {\n        options.cookieOptions.maxAge = computeCookieMaxAge(\n          userSessionOptions.cookieOptions.maxAge\n        );\n      }\n    } else {\n      options.cookieOptions.maxAge = computeCookieMaxAge(options.ttl);\n    }\n    const sealFromCookies = import_cookie.default.parse(\n      \"credentials\" in req ? req.headers.get(\"cookie\") || \"\" : req.headers.cookie || \"\"\n    )[options.cookieName];\n    const session = sealFromCookies === void 0 ? {} : await unsealData2(sealFromCookies, {\n      password: passwordsAsMap,\n      ttl: options.ttl\n    });\n    Object.defineProperties(session, {\n      save: {\n        value: async function save() {\n          if (\"headersSent\" in res && res.headersSent === true) {\n            throw new Error(\n              `iron-session: Cannot set session cookie: session.save() was called after headers were sent. Make sure to call it before any res.send() or res.end()`\n            );\n          }\n          const seal2 = await sealData2(session, {\n            password: passwordsAsMap,\n            ttl: options.ttl\n          });\n          const cookieValue = import_cookie.default.serialize(\n            options.cookieName,\n            seal2,\n            options.cookieOptions\n          );\n          if (cookieValue.length > 4096) {\n            throw new Error(\n              `iron-session: Cookie length is too big ${cookieValue.length}, browsers will refuse it. Try to remove some data.`\n            );\n          }\n          addToCookies(cookieValue, res);\n        }\n      },\n      destroy: {\n        value: function destroy() {\n          Object.keys(session).forEach((key) => {\n            delete session[key];\n          });\n          const cookieValue = import_cookie.default.serialize(options.cookieName, \"\", {\n            ...options.cookieOptions,\n            maxAge: 0\n          });\n          addToCookies(cookieValue, res);\n        }\n      }\n    });\n    return session;\n  };\n}\nfunction addToCookies(cookieValue, res) {\n  var _a;\n  if (\"headers\" in res) {\n    res.headers.append(\"set-cookie\", cookieValue);\n    return;\n  }\n  let existingSetCookie = (_a = res.getHeader(\"set-cookie\")) != null ? _a : [];\n  if (typeof existingSetCookie === \"string\") {\n    existingSetCookie = [existingSetCookie];\n  }\n  res.setHeader(\"set-cookie\", [...existingSetCookie, cookieValue]);\n}\nfunction computeCookieMaxAge(ttl) {\n  return ttl - timestampSkewSec;\n}\nfunction createUnsealData(_crypto2) {\n  return async (seal2, {\n    password,\n    ttl = fourteenDaysInSeconds\n  }) => {\n    const passwordsAsMap = normalizeStringPasswordToMap(password);\n    const { sealWithoutVersion, tokenVersion } = parseSeal(seal2);\n    try {\n      const data = await Iron.unseal(_crypto2, sealWithoutVersion, passwordsAsMap, {\n        ...Iron.defaults,\n        ttl: ttl * 1e3\n      }) || {};\n      if (tokenVersion === 2) {\n        return data;\n      }\n      return {\n        ...data.persistent\n      };\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message === \"Expired seal\" || error.message === \"Bad hmac value\" || error.message.startsWith(\"Cannot find password: \") || error.message === \"Incorrect number of sealed components\") {\n          return {};\n        }\n      }\n      throw error;\n    }\n  };\n}\nfunction parseSeal(seal2) {\n  if (seal2[seal2.length - 2] === versionDelimiter) {\n    const [sealWithoutVersion, tokenVersionAsString] = seal2.split(versionDelimiter);\n    return {\n      sealWithoutVersion,\n      tokenVersion: parseInt(tokenVersionAsString, 10)\n    };\n  }\n  return { sealWithoutVersion: seal2, tokenVersion: null };\n}\nfunction createSealData(_crypto2) {\n  return async (data, {\n    password,\n    ttl = fourteenDaysInSeconds\n  }) => {\n    const passwordsAsMap = normalizeStringPasswordToMap(password);\n    const mostRecentPasswordId = Math.max(\n      ...Object.keys(passwordsAsMap).map((id) => parseInt(id, 10))\n    );\n    const passwordForSeal = {\n      id: mostRecentPasswordId.toString(),\n      secret: passwordsAsMap[mostRecentPasswordId]\n    };\n    const seal2 = await Iron.seal(_crypto2, data, passwordForSeal, {\n      ...Iron.defaults,\n      ttl: ttl * 1e3\n    });\n    return `${seal2}${versionDelimiter}${currentMajorVersion}`;\n  };\n}\nfunction normalizeStringPasswordToMap(password) {\n  return typeof password === \"string\" ? { 1: password } : password;\n}\n\n// src/index.ts\nvar import_webcrypto = __webpack_require__(/*! @peculiar/webcrypto */ \"(rsc)/../../../node_modules/@peculiar/webcrypto/build/webcrypto.es.js\");\nvar _crypto = new import_webcrypto.Crypto();\nvar unsealData = createUnsealData(_crypto);\nvar sealData = createSealData(_crypto);\nvar getIronSession = createGetIronSession(\n  _crypto,\n  unsealData,\n  sealData\n);\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lyb24tc2Vzc2lvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQzNDLDRCQUE0QixtQkFBTyxDQUFDLHFGQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQU9MO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qb2ItYm9hcmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lyb24tc2Vzc2lvbi9kaXN0L2luZGV4LmpzP2IyMjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIGNyZWF0ZUdldElyb25TZXNzaW9uOiAoKSA9PiBjcmVhdGVHZXRJcm9uU2Vzc2lvbixcbiAgY3JlYXRlU2VhbERhdGE6ICgpID0+IGNyZWF0ZVNlYWxEYXRhLFxuICBjcmVhdGVVbnNlYWxEYXRhOiAoKSA9PiBjcmVhdGVVbnNlYWxEYXRhLFxuICBnZXRJcm9uU2Vzc2lvbjogKCkgPT4gZ2V0SXJvblNlc3Npb24sXG4gIHNlYWxEYXRhOiAoKSA9PiBzZWFsRGF0YSxcbiAgdW5zZWFsRGF0YTogKCkgPT4gdW5zZWFsRGF0YVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG5cbi8vIHNyYy9jb3JlLnRzXG52YXIgSXJvbiA9IF9fdG9FU00ocmVxdWlyZShcImlyb24td2ViY3J5cHRvXCIpKTtcbnZhciBpbXBvcnRfY29va2llID0gX190b0VTTShyZXF1aXJlKFwiY29va2llXCIpKTtcbnZhciB0aW1lc3RhbXBTa2V3U2VjID0gNjA7XG52YXIgZm91cnRlZW5EYXlzSW5TZWNvbmRzID0gMTUgKiAyNCAqIDM2MDA7XG52YXIgY3VycmVudE1ham9yVmVyc2lvbiA9IDI7XG52YXIgdmVyc2lvbkRlbGltaXRlciA9IFwiflwiO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICB0dGw6IGZvdXJ0ZWVuRGF5c0luU2Vjb25kcyxcbiAgY29va2llT3B0aW9uczoge1xuICAgIGh0dHBPbmx5OiB0cnVlLFxuICAgIHNlY3VyZTogdHJ1ZSxcbiAgICBzYW1lU2l0ZTogXCJsYXhcIixcbiAgICBwYXRoOiBcIi9cIlxuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlR2V0SXJvblNlc3Npb24oX2NyeXB0bzIsIHVuc2VhbERhdGEyLCBzZWFsRGF0YTIpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgdXNlclNlc3Npb25PcHRpb25zKSA9PiB7XG4gICAgaWYgKCFyZXEgfHwgIXJlcyB8fCAhdXNlclNlc3Npb25PcHRpb25zIHx8ICF1c2VyU2Vzc2lvbk9wdGlvbnMuY29va2llTmFtZSB8fCAhdXNlclNlc3Npb25PcHRpb25zLnBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBpcm9uLXNlc3Npb246IEJhZCB1c2FnZS4gTWluaW11bSB1c2FnZSBpcyBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0SXJvblNlc3Npb24ocmVxLCByZXMsIHsgY29va2llTmFtZTogXCIuLi5cIiwgcGFzc3dvcmQ6IFwiLi4uXCIuIENoZWNrIHRoZSB1c2FnZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdnZvL2lyb24tc2Vzc2lvbmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHBhc3N3b3Jkc0FzTWFwID0gbm9ybWFsaXplU3RyaW5nUGFzc3dvcmRUb01hcChcbiAgICAgIHVzZXJTZXNzaW9uT3B0aW9ucy5wYXNzd29yZFxuICAgICk7XG4gICAgT2JqZWN0LnZhbHVlcyhcbiAgICAgIG5vcm1hbGl6ZVN0cmluZ1Bhc3N3b3JkVG9NYXAodXNlclNlc3Npb25PcHRpb25zLnBhc3N3b3JkKVxuICAgICkuZm9yRWFjaCgocGFzc3dvcmQpID0+IHtcbiAgICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYGlyb24tc2Vzc2lvbjogQmFkIHVzYWdlLiBQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDMyIGNoYXJhY3RlcnMgbG9uZy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udXNlclNlc3Npb25PcHRpb25zLFxuICAgICAgY29va2llT3B0aW9uczoge1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucy5jb29raWVPcHRpb25zLFxuICAgICAgICAuLi51c2VyU2Vzc2lvbk9wdGlvbnMuY29va2llT3B0aW9ucyB8fCB7fVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMudHRsID09PSAwKSB7XG4gICAgICBvcHRpb25zLnR0bCA9IDIxNDc0ODM2NDc7XG4gICAgfVxuICAgIGlmICh1c2VyU2Vzc2lvbk9wdGlvbnMuY29va2llT3B0aW9ucyAmJiBcIm1heEFnZVwiIGluIHVzZXJTZXNzaW9uT3B0aW9ucy5jb29raWVPcHRpb25zKSB7XG4gICAgICBpZiAodXNlclNlc3Npb25PcHRpb25zLmNvb2tpZU9wdGlvbnMubWF4QWdlID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucy50dGwgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5jb29raWVPcHRpb25zLm1heEFnZSA9IGNvbXB1dGVDb29raWVNYXhBZ2UoXG4gICAgICAgICAgdXNlclNlc3Npb25PcHRpb25zLmNvb2tpZU9wdGlvbnMubWF4QWdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuY29va2llT3B0aW9ucy5tYXhBZ2UgPSBjb21wdXRlQ29va2llTWF4QWdlKG9wdGlvbnMudHRsKTtcbiAgICB9XG4gICAgY29uc3Qgc2VhbEZyb21Db29raWVzID0gaW1wb3J0X2Nvb2tpZS5kZWZhdWx0LnBhcnNlKFxuICAgICAgXCJjcmVkZW50aWFsc1wiIGluIHJlcSA/IHJlcS5oZWFkZXJzLmdldChcImNvb2tpZVwiKSB8fCBcIlwiIDogcmVxLmhlYWRlcnMuY29va2llIHx8IFwiXCJcbiAgICApW29wdGlvbnMuY29va2llTmFtZV07XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHNlYWxGcm9tQ29va2llcyA9PT0gdm9pZCAwID8ge30gOiBhd2FpdCB1bnNlYWxEYXRhMihzZWFsRnJvbUNvb2tpZXMsIHtcbiAgICAgIHBhc3N3b3JkOiBwYXNzd29yZHNBc01hcCxcbiAgICAgIHR0bDogb3B0aW9ucy50dGxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZXNzaW9uLCB7XG4gICAgICBzYXZlOiB7XG4gICAgICAgIHZhbHVlOiBhc3luYyBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgICAgIGlmIChcImhlYWRlcnNTZW50XCIgaW4gcmVzICYmIHJlcy5oZWFkZXJzU2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgaXJvbi1zZXNzaW9uOiBDYW5ub3Qgc2V0IHNlc3Npb24gY29va2llOiBzZXNzaW9uLnNhdmUoKSB3YXMgY2FsbGVkIGFmdGVyIGhlYWRlcnMgd2VyZSBzZW50LiBNYWtlIHN1cmUgdG8gY2FsbCBpdCBiZWZvcmUgYW55IHJlcy5zZW5kKCkgb3IgcmVzLmVuZCgpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2VhbDIgPSBhd2FpdCBzZWFsRGF0YTIoc2Vzc2lvbiwge1xuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3Jkc0FzTWFwLFxuICAgICAgICAgICAgdHRsOiBvcHRpb25zLnR0bFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGNvb2tpZVZhbHVlID0gaW1wb3J0X2Nvb2tpZS5kZWZhdWx0LnNlcmlhbGl6ZShcbiAgICAgICAgICAgIG9wdGlvbnMuY29va2llTmFtZSxcbiAgICAgICAgICAgIHNlYWwyLFxuICAgICAgICAgICAgb3B0aW9ucy5jb29raWVPcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoY29va2llVmFsdWUubGVuZ3RoID4gNDA5Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgaXJvbi1zZXNzaW9uOiBDb29raWUgbGVuZ3RoIGlzIHRvbyBiaWcgJHtjb29raWVWYWx1ZS5sZW5ndGh9LCBicm93c2VycyB3aWxsIHJlZnVzZSBpdC4gVHJ5IHRvIHJlbW92ZSBzb21lIGRhdGEuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkVG9Db29raWVzKGNvb2tpZVZhbHVlLCByZXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveToge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzZXNzaW9uKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZXNzaW9uW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgY29va2llVmFsdWUgPSBpbXBvcnRfY29va2llLmRlZmF1bHQuc2VyaWFsaXplKG9wdGlvbnMuY29va2llTmFtZSwgXCJcIiwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucy5jb29raWVPcHRpb25zLFxuICAgICAgICAgICAgbWF4QWdlOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkVG9Db29raWVzKGNvb2tpZVZhbHVlLCByZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlc3Npb247XG4gIH07XG59XG5mdW5jdGlvbiBhZGRUb0Nvb2tpZXMoY29va2llVmFsdWUsIHJlcykge1xuICB2YXIgX2E7XG4gIGlmIChcImhlYWRlcnNcIiBpbiByZXMpIHtcbiAgICByZXMuaGVhZGVycy5hcHBlbmQoXCJzZXQtY29va2llXCIsIGNvb2tpZVZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGV4aXN0aW5nU2V0Q29va2llID0gKF9hID0gcmVzLmdldEhlYWRlcihcInNldC1jb29raWVcIikpICE9IG51bGwgPyBfYSA6IFtdO1xuICBpZiAodHlwZW9mIGV4aXN0aW5nU2V0Q29va2llID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXhpc3RpbmdTZXRDb29raWUgPSBbZXhpc3RpbmdTZXRDb29raWVdO1xuICB9XG4gIHJlcy5zZXRIZWFkZXIoXCJzZXQtY29va2llXCIsIFsuLi5leGlzdGluZ1NldENvb2tpZSwgY29va2llVmFsdWVdKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb29raWVNYXhBZ2UodHRsKSB7XG4gIHJldHVybiB0dGwgLSB0aW1lc3RhbXBTa2V3U2VjO1xufVxuZnVuY3Rpb24gY3JlYXRlVW5zZWFsRGF0YShfY3J5cHRvMikge1xuICByZXR1cm4gYXN5bmMgKHNlYWwyLCB7XG4gICAgcGFzc3dvcmQsXG4gICAgdHRsID0gZm91cnRlZW5EYXlzSW5TZWNvbmRzXG4gIH0pID0+IHtcbiAgICBjb25zdCBwYXNzd29yZHNBc01hcCA9IG5vcm1hbGl6ZVN0cmluZ1Bhc3N3b3JkVG9NYXAocGFzc3dvcmQpO1xuICAgIGNvbnN0IHsgc2VhbFdpdGhvdXRWZXJzaW9uLCB0b2tlblZlcnNpb24gfSA9IHBhcnNlU2VhbChzZWFsMik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBJcm9uLnVuc2VhbChfY3J5cHRvMiwgc2VhbFdpdGhvdXRWZXJzaW9uLCBwYXNzd29yZHNBc01hcCwge1xuICAgICAgICAuLi5Jcm9uLmRlZmF1bHRzLFxuICAgICAgICB0dGw6IHR0bCAqIDFlM1xuICAgICAgfSkgfHwge307XG4gICAgICBpZiAodG9rZW5WZXJzaW9uID09PSAyKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGF0YS5wZXJzaXN0ZW50XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gXCJFeHBpcmVkIHNlYWxcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcIkJhZCBobWFjIHZhbHVlXCIgfHwgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2Fubm90IGZpbmQgcGFzc3dvcmQ6IFwiKSB8fCBlcnJvci5tZXNzYWdlID09PSBcIkluY29ycmVjdCBudW1iZXIgb2Ygc2VhbGVkIGNvbXBvbmVudHNcIikge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VTZWFsKHNlYWwyKSB7XG4gIGlmIChzZWFsMltzZWFsMi5sZW5ndGggLSAyXSA9PT0gdmVyc2lvbkRlbGltaXRlcikge1xuICAgIGNvbnN0IFtzZWFsV2l0aG91dFZlcnNpb24sIHRva2VuVmVyc2lvbkFzU3RyaW5nXSA9IHNlYWwyLnNwbGl0KHZlcnNpb25EZWxpbWl0ZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWFsV2l0aG91dFZlcnNpb24sXG4gICAgICB0b2tlblZlcnNpb246IHBhcnNlSW50KHRva2VuVmVyc2lvbkFzU3RyaW5nLCAxMClcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IHNlYWxXaXRob3V0VmVyc2lvbjogc2VhbDIsIHRva2VuVmVyc2lvbjogbnVsbCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VhbERhdGEoX2NyeXB0bzIpIHtcbiAgcmV0dXJuIGFzeW5jIChkYXRhLCB7XG4gICAgcGFzc3dvcmQsXG4gICAgdHRsID0gZm91cnRlZW5EYXlzSW5TZWNvbmRzXG4gIH0pID0+IHtcbiAgICBjb25zdCBwYXNzd29yZHNBc01hcCA9IG5vcm1hbGl6ZVN0cmluZ1Bhc3N3b3JkVG9NYXAocGFzc3dvcmQpO1xuICAgIGNvbnN0IG1vc3RSZWNlbnRQYXNzd29yZElkID0gTWF0aC5tYXgoXG4gICAgICAuLi5PYmplY3Qua2V5cyhwYXNzd29yZHNBc01hcCkubWFwKChpZCkgPT4gcGFyc2VJbnQoaWQsIDEwKSlcbiAgICApO1xuICAgIGNvbnN0IHBhc3N3b3JkRm9yU2VhbCA9IHtcbiAgICAgIGlkOiBtb3N0UmVjZW50UGFzc3dvcmRJZC50b1N0cmluZygpLFxuICAgICAgc2VjcmV0OiBwYXNzd29yZHNBc01hcFttb3N0UmVjZW50UGFzc3dvcmRJZF1cbiAgICB9O1xuICAgIGNvbnN0IHNlYWwyID0gYXdhaXQgSXJvbi5zZWFsKF9jcnlwdG8yLCBkYXRhLCBwYXNzd29yZEZvclNlYWwsIHtcbiAgICAgIC4uLklyb24uZGVmYXVsdHMsXG4gICAgICB0dGw6IHR0bCAqIDFlM1xuICAgIH0pO1xuICAgIHJldHVybiBgJHtzZWFsMn0ke3ZlcnNpb25EZWxpbWl0ZXJ9JHtjdXJyZW50TWFqb3JWZXJzaW9ufWA7XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQYXNzd29yZFRvTWFwKHBhc3N3b3JkKSB7XG4gIHJldHVybiB0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgPyB7IDE6IHBhc3N3b3JkIH0gOiBwYXNzd29yZDtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW1wb3J0X3dlYmNyeXB0byA9IHJlcXVpcmUoXCJAcGVjdWxpYXIvd2ViY3J5cHRvXCIpO1xudmFyIF9jcnlwdG8gPSBuZXcgaW1wb3J0X3dlYmNyeXB0by5DcnlwdG8oKTtcbnZhciB1bnNlYWxEYXRhID0gY3JlYXRlVW5zZWFsRGF0YShfY3J5cHRvKTtcbnZhciBzZWFsRGF0YSA9IGNyZWF0ZVNlYWxEYXRhKF9jcnlwdG8pO1xudmFyIGdldElyb25TZXNzaW9uID0gY3JlYXRlR2V0SXJvblNlc3Npb24oXG4gIF9jcnlwdG8sXG4gIHVuc2VhbERhdGEsXG4gIHNlYWxEYXRhXG4pO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUdldElyb25TZXNzaW9uLFxuICBjcmVhdGVTZWFsRGF0YSxcbiAgY3JlYXRlVW5zZWFsRGF0YSxcbiAgZ2V0SXJvblNlc3Npb24sXG4gIHNlYWxEYXRhLFxuICB1bnNlYWxEYXRhXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/iron-session/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/iron-session/node_modules/cookie/index.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/iron-session/node_modules/cookie/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lyb24tc2Vzc2lvbi9ub2RlX21vZHVsZXMvY29va2llL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0Msa0JBQWtCO0FBQ2xCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pvYi1ib2FyZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaXJvbi1zZXNzaW9uL25vZGVfbW9kdWxlcy9jb29raWUvaW5kZXguanM/ODEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGNvb2tpZVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBSb21hbiBTaHR5bG1hblxuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgX190b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggZmllbGQtY29udGVudCBpbiBSRkMgNzIzMCBzZWMgMy4yXG4gKlxuICogZmllbGQtY29udGVudCA9IGZpZWxkLXZjaGFyIFsgMSooIFNQIC8gSFRBQiApIGZpZWxkLXZjaGFyIF1cbiAqIGZpZWxkLXZjaGFyICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKiBvYnMtdGV4dCAgICAgID0gJXg4MC1GRlxuICovXG5cbnZhciBmaWVsZENvbnRlbnRSZWdFeHAgPSAvXltcXHUwMDA5XFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHUwMGZmXSskLztcblxuLyoqXG4gKiBQYXJzZSBhIGNvb2tpZSBoZWFkZXIuXG4gKlxuICogUGFyc2UgdGhlIGdpdmVuIGNvb2tpZSBoZWFkZXIgc3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKiBUaGUgb2JqZWN0IGhhcyB0aGUgdmFyaW91cyBjb29raWVzIGFzIGtleXMobmFtZXMpID0+IHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBvYmogPSB7fVxuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGRlYyA9IG9wdC5kZWNvZGUgfHwgZGVjb2RlO1xuXG4gIHZhciBpbmRleCA9IDBcbiAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHZhciBlcUlkeCA9IHN0ci5pbmRleE9mKCc9JywgaW5kZXgpXG5cbiAgICAvLyBubyBtb3JlIGNvb2tpZSBwYWlyc1xuICAgIGlmIChlcUlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdmFyIGVuZElkeCA9IHN0ci5pbmRleE9mKCc7JywgaW5kZXgpXG5cbiAgICBpZiAoZW5kSWR4ID09PSAtMSkge1xuICAgICAgZW5kSWR4ID0gc3RyLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAoZW5kSWR4IDwgZXFJZHgpIHtcbiAgICAgIC8vIGJhY2t0cmFjayBvbiBwcmlvciBzZW1pY29sb25cbiAgICAgIGluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCc7JywgZXFJZHggLSAxKSArIDFcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHN0ci5zbGljZShpbmRleCwgZXFJZHgpLnRyaW0oKVxuXG4gICAgLy8gb25seSBhc3NpZ24gb25jZVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9ialtrZXldKSB7XG4gICAgICB2YXIgdmFsID0gc3RyLnNsaWNlKGVxSWR4ICsgMSwgZW5kSWR4KS50cmltKClcblxuICAgICAgLy8gcXVvdGVkIHZhbHVlc1xuICAgICAgaWYgKHZhbC5jaGFyQ29kZUF0KDApID09PSAweDIyKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zbGljZSgxLCAtMSlcbiAgICAgIH1cblxuICAgICAgb2JqW2tleV0gPSB0cnlEZWNvZGUodmFsLCBkZWMpO1xuICAgIH1cblxuICAgIGluZGV4ID0gZW5kSWR4ICsgMVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgZGF0YSBpbnRvIGEgY29va2llIGhlYWRlci5cbiAqXG4gKiBTZXJpYWxpemUgdGhlIGEgbmFtZSB2YWx1ZSBwYWlyIGludG8gYSBjb29raWUgc3RyaW5nIHN1aXRhYmxlIGZvclxuICogaHR0cCBoZWFkZXJzLiBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCBzcGVjaWZpZWQgY29va2llIHBhcmFtZXRlcnMuXG4gKlxuICogc2VyaWFsaXplKCdmb28nLCAnYmFyJywgeyBodHRwT25seTogdHJ1ZSB9KVxuICogICA9PiBcImZvbz1iYXI7IGh0dHBPbmx5XCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShuYW1lLCB2YWwsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG4gIHZhciBlbmMgPSBvcHQuZW5jb2RlIHx8IGVuY29kZTtcblxuICBpZiAodHlwZW9mIGVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBlbmNvZGUgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG5hbWUgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gZW5jKHZhbCk7XG5cbiAgaWYgKHZhbHVlICYmICFmaWVsZENvbnRlbnRSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCB2YWwgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHN0ciA9IG5hbWUgKyAnPScgKyB2YWx1ZTtcblxuICBpZiAobnVsbCAhPSBvcHQubWF4QWdlKSB7XG4gICAgdmFyIG1heEFnZSA9IG9wdC5tYXhBZ2UgLSAwO1xuXG4gICAgaWYgKGlzTmFOKG1heEFnZSkgfHwgIWlzRmluaXRlKG1heEFnZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBtYXhBZ2UgaXMgaW52YWxpZCcpXG4gICAgfVxuXG4gICAgc3RyICs9ICc7IE1heC1BZ2U9JyArIE1hdGguZmxvb3IobWF4QWdlKTtcbiAgfVxuXG4gIGlmIChvcHQuZG9tYWluKSB7XG4gICAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChvcHQuZG9tYWluKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGRvbWFpbiBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgc3RyICs9ICc7IERvbWFpbj0nICsgb3B0LmRvbWFpbjtcbiAgfVxuXG4gIGlmIChvcHQucGF0aCkge1xuICAgIGlmICghZmllbGRDb250ZW50UmVnRXhwLnRlc3Qob3B0LnBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gcGF0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgc3RyICs9ICc7IFBhdGg9JyArIG9wdC5wYXRoO1xuICB9XG5cbiAgaWYgKG9wdC5leHBpcmVzKSB7XG4gICAgdmFyIGV4cGlyZXMgPSBvcHQuZXhwaXJlc1xuXG4gICAgaWYgKCFpc0RhdGUoZXhwaXJlcykgfHwgaXNOYU4oZXhwaXJlcy52YWx1ZU9mKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gZXhwaXJlcyBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgc3RyICs9ICc7IEV4cGlyZXM9JyArIGV4cGlyZXMudG9VVENTdHJpbmcoKVxuICB9XG5cbiAgaWYgKG9wdC5odHRwT25seSkge1xuICAgIHN0ciArPSAnOyBIdHRwT25seSc7XG4gIH1cblxuICBpZiAob3B0LnNlY3VyZSkge1xuICAgIHN0ciArPSAnOyBTZWN1cmUnO1xuICB9XG5cbiAgaWYgKG9wdC5wcmlvcml0eSkge1xuICAgIHZhciBwcmlvcml0eSA9IHR5cGVvZiBvcHQucHJpb3JpdHkgPT09ICdzdHJpbmcnXG4gICAgICA/IG9wdC5wcmlvcml0eS50b0xvd2VyQ2FzZSgpXG4gICAgICA6IG9wdC5wcmlvcml0eVxuXG4gICAgc3dpdGNoIChwcmlvcml0eSkge1xuICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgc3RyICs9ICc7IFByaW9yaXR5PUxvdydcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgIHN0ciArPSAnOyBQcmlvcml0eT1NZWRpdW0nXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgc3RyICs9ICc7IFByaW9yaXR5PUhpZ2gnXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gcHJpb3JpdHkgaXMgaW52YWxpZCcpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgIHZhciBzYW1lU2l0ZSA9IHR5cGVvZiBvcHQuc2FtZVNpdGUgPT09ICdzdHJpbmcnXG4gICAgICA/IG9wdC5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpIDogb3B0LnNhbWVTaXRlO1xuXG4gICAgc3dpdGNoIChzYW1lU2l0ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9U3RyaWN0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsYXgnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9TGF4JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpY3QnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9U3RyaWN0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdub25lJzpcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBzYW1lU2l0ZSBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBVUkwtZGVjb2RlIHN0cmluZyB2YWx1ZS4gT3B0aW1pemVkIHRvIHNraXAgbmF0aXZlIGNhbGwgd2hlbiBubyAlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKCclJykgIT09IC0xXG4gICAgPyBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgIDogc3RyXG59XG5cbi8qKlxuICogVVJMLWVuY29kZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZSAodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB2YWx1ZSBpcyBhIERhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNEYXRlICh2YWwpIHtcbiAgcmV0dXJuIF9fdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXScgfHxcbiAgICB2YWwgaW5zdGFuY2VvZiBEYXRlXG59XG5cbi8qKlxuICogVHJ5IGRlY29kaW5nIGEgc3RyaW5nIHVzaW5nIGEgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGVjb2RlXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHRyeURlY29kZShzdHIsIGRlY29kZSkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGUoc3RyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/iron-session/node_modules/cookie/index.js\n");

/***/ })

};
;